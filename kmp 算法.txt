在一个大字符串中间匹配一个模式串(记为P);

所有的方法的根本在于建立一个 移位的表和一个比较索引表;

例如,
最传统最笨的办法就是: 每次遇到不匹配的字母时,将模式串向后移动一位;
得到的移步表为 [1,1,1,1,...,1,...],且每次从第一个字符开始比较,得到的比较索引表[0,0,0,...,0,...];
(记移步表为 step,比较索引表为index)

传统方法,step表和 index表的建立十分简单,但是进行了许多不必要的比较,复杂度很高;

step[i]:	表示在比较的时候,不匹配的字母发生在模式串的第i个位置时, 需要将A字符串向后移动的步数(其实这里的移位也只是形象的描述)
index[i]:	表示在移动完毕之后(开始比较之时), P字符串开始比较的位置索引;

KMP法:也是同样的道理,需要建立step表和index表,(kmp貌似有很多版本,主要是第一项的不同,我们取第一项为next[0]=-1);
KMP法中, 需要建立next表, 其实其与step表是一一对应的, step[i] = i-next[i] ;
		KMP法中,貌似没有建立index表, 其实是建立了的, index与next也是一一对应的;index[i] = next[i];

KMP法(伪代码实现):
	1. 求出next[];(我们记原字符串为C-context串;模式串为P-pattern)
	2. 令 i=0;j=0;(其中形象来说i指向C串, j指向P串,j同时表示了C串中当前比较的字符与i指向的字符的间隔)
	3. 很容易的, 我们知道i和j的范围;
		0 <= i <= c-p+1 (c表示c串的长度,p表示p串的长度);当i取到上界时,结果是匹配失败
		0 <= j <= p (当j取到上界,结果是匹配成功);
	4. 构造循环:
		比较 C[i+j] == P[j];
		如果相等, 则j++(比较下一个字母,i不变);
		如果不等(即第j个字母不匹配,前j-1个字母匹配), 则我们去查next[j]赋值给index;然后我们计算出需要移动的步数step = j-index;
		于是  i += step; 然后比较不一定是从0开始比, 而是从 index开始比,于是把 index 赋值给 j;
		得到新的i和j; 进行循环条件的判断(i==c-p+1 || j==p);

上述思想,的确是将搜索步骤大大简化了, 但是并不是最简;主要原因在于next的数组里面的数字并不是在允许的情况下 的最小值;
step表示,某个字母不匹配,p串向后移动的步数,如果step尽可能的大(当然在不漏掉匹配的情况下),那么比较的次数不就是尽可能的小了么?

举个例子: 我们设 P = "ABCABC";可以得到next是 [-1,0,0,0,1,2](具体的求法后面说);
I:	0	1	2	3	4	5	(字母索引)
P:	A	B	C	A	B	C	(模式串)
N:	-1	0	0	0	1	2	(next序列)
S:	1	1	2	3	3	3	(step序列)
上述得到的step分别是第I个字母不匹配,需要向右移动S步,(下面讲述一下为什么是移动S步)
(我们记原字符串为C-context串;模式串为P-pattern)
例如 C = "ABCX XXXXXXXX";
C	A-B-C-X- -X-X ...
P	A-B-C-A- ...
我们比较她们, 发现前三个字母都一样,第四个不一样了; P中 第四个字母是A;
于是考虑将P往后移动, 移动几位呢?(原则是移动到必须要比较的地方,要尽可能的利用已经比较过的信息)

根据第一次比较之后,我们知道,
	P[3]!= C[3];  P[2]==C[2];P[1]==C[1];P[0]==C[0];
	根据P串,我们知道,P[0]!=P[1]!=P[2]; P[0]==P[3];
	所以必然可以得到 一系列的 等与不等 的关系;

如果移动一位,
C	A-B-C-X- - ...
P	--A-B-C-A- ...
	就是 P[0,2](表示P[0],P[1],P[2],下面类似的表示方法也是一样的意思)要与C[1,3]比;我们不知道P[2]与C[3]的关系;
	但是我们知道,P[1]!=C[2];(因为P[1]!=P[2], P[2]==C[2]下面将不再解释为什么等或者不等);
	所以没必要移动一位去比较匹配与否;

于是考虑移动两位:(其实类似的道理可以知道两位也不行)

然后移动3(S = 3)位:
C	A-B-C-X- - ...
P	------A-B-C-A- ...
	将P[0]与C[3]比较; (KMP算法就是移动3位, 进行下一轮的循环的,但是很显然不合适);
		P[0]==P[3], P[3] != C[3]; 那么 P[0] != C[3];这样同样是没有必要比较的,于是私以为移动三步不合适(KMP算法需要进行改进);

最后我们看移动4步:根据已有的比较信息,我们无法知道 P[0] 与 C[4]的关系;因为必须要比较于是 应当移动4位;
于是我们可以得出最佳的移动步数的表(step,记为s');

I:	0	1	2	3	4	5
P:	A	B	C	A	B	C
N:	-1	0	0	0	1	2
S:	1	1	2	3	3	3

S':	1	1	2	4	4	5
(很显然,在不漏掉正确匹配的情况下, 尽可能多的利用已有的比较的信息,可以得到更佳的移动步数---这也正是KMP算法的核心思想)
(但是KMP算法美中不足的地方在于,它少利用了一个条件:P[0]==P[3],于是导致了KMP算法的效率并不是最佳的)

小结一下上述的内容:
	上面已经讲到了, 如何利用next表来进行操作;

那么下面将讲到,为什么next表具有这样优良的属性,能够直接得到比较优秀的移动位数呢?

首先,来说这个next表如何得到:
	规定 next[0] = -1;(为了使 step[0] = 1);
	next[j]: P[0,j-1]是一个子字符串;找到最大k,使得
	字符串 P[0,k] == p[j-1-k,j-1] ( 0 < k < j-1 ,注意 k!=j-1)(其实也就是P[0,j-1]字符串的前缀和后缀相同的最大长度)
	那么这个最大k就是next[j]了;(如果找不到就取0了)

	举个例子: 用上面的那个 字符串: ABCABC;
	j=0: next[0] = -1;
	j=1: 子字符串是 "A"; 找不到,k取0;(前缀和后缀都没有)
	j=2: 子字符串是 "AB";找不到,k取0;(前缀只有A,后缀只有B,相等的没有)
	j=3: 子字符串是 "ABC";找不到,k取0;(前缀是A,AB;后缀是 C,BC,没有相等的)
	j=4: 子字符串是 "ABCA";找到了A=A,k取1;(前缀是A,AB,ABC;后缀是A,CA,BCA;相等的有A=A,长度为1)
	j=5: 子字符串是 "ABCAB";找到了AB=AB,A=A,k=2或k=1 : 取2;(前缀是A,AB,ABC,ABCA;后缀是B,AB,CAB,BCAB;相等的有A=A,AB=AB,长度最大为2)
	如果j=6: k=3;

然后我们来讲一下,为什么这样来获取这个next表,就能够得到较好的步数:
	大家回忆一下咱们上面是怎么做的:(通过移动P串,进行比较)

	假设,不匹配的字母发生在第j个位置;(也就是说前j-1个字母匹配P[0,j-1] == C[0,j-1], P[j]!=C[j] );
	如果我们移动 1 位: 需要将 P[0,j] 与 C[1,j+1]比较;但是由于已知的条件; P[1,j-1] == C[1,j-1] ;
	于是,要比较的是:  P[0,j-2],P[j-1],P[j] 与 P[1,j-1],C[j],C[j+1]; (下面来看有没有比较的意义,如果有就是步数就是取这个)
	P[j] --- C[j+1] : 显然不知道关系,因为 C[j+1] 之前没有被比较过;

	( 优化之后的方法:
		P[j-1] --- C[j] : (这一步就是 KMP法的不足之处, 它并没有用到这一步的关系)
			我们知道 P[j]!=C[j]; 如果 P[j]!=P[j-1] 那么就需要比较,反之P[j]==p[j-1],那么P[j-1]!=C[j];那么接下来也就不用比了,肯定不匹配
		P[0,j-2] --- P[1,j-1]; 这里就是上述步骤中取k的步骤了:这里k=j-2;
	)

	KMP法跳过括号的部分直接到这里, 并没有用到P[j-1]!=C[j];而是直接比较: P[0,j-2] 与 P[1,j-1];
		如果相等,表示这样做是可以的;其实这样做就是在找子字符串的前缀和后缀的最大长度
	(所以找最大的K 就是这样来的)

好了,到这里,KMP法已经分析完了, 分析的时候, 已经说明了KMP法有不足之处;我们通过设计新的 next 序列来优化它;

I:	0	1	2	3	4	5
P:	A	B	C	A	B	C

N:	-1	0	0	0	1	2
首先,还是利用KMP算出 最初的next;
(我们说, KMP法移动的位数不够大,也就是N不够小);

改进,利用P[ N[j] ] 与 P[j]如果不相等,那么按照原有的移动 j-N[j],(N[j]=N[j]) 位; 如果相等,N[j]=N[ N[j] ],
循环该步骤,直到N[j]=-1,或者P[ N[j] ] 与 P[j]不相等为止;
(相当于是建立了N[j]的迭代序列, 必然是收敛的,收敛到最优解)
按照上面的例子:
	next[0] = N[0] = -1;(等于-1,循环退出)
	next[1] = N[1] = 0;(判断P[1]!=P[0],循环结束)
	next[2] = N[2] = 0;(判断P[2]!=P[0],循环结束)
	next[3] = N[3] = 0;(判断P[3]==P[0],于是 next[3] = N[ N[3] ] = N[0] = -1,循环结束);
	next[4] = N[4] = 1;(判断P[4]==P[1],于是 next[4] = N[ N[4] ] = N[1] = 0,判断P[4]!=P[0],循环结束);
	next[5] = N[5] = 2;(判断P[5]==P[2],于是 next[5] = N[ N[5] ] = N[2] = 0,判断P[5]!=P[0],循环结束);
最终得到next
I:	0	1	2	3	4	5
P:	A	B	C	A	B	C
N:	-1	0	0	0	1	2
N':	-1	0	0	-1	0	0

于是得到移动位数 j-N'[j];
S':	1	1	2	4	4	5(与最上面的,人工推导的最优解一样,胜利!)

这种方法找到了step表; 那么index 表呢?  我们知道 KMP法 的index表就是 next序列,那么这个新的next序列是不是合适呢?
(一看,新的序列里面出现了负数,index表里可不能有负数,)
于是 我们index表就这样来建立:
	-1 全部按照0 来算;  其他的数按照它本身的数;
index = [0,0,0,0,0,0]

我们再举一个其他的例子:
C = "ABCDAABCDACD"
P = "AABCDACD";

I:	0	1	2	3	4	5	6	7
P:	A	B	B	A	B	B	A	D

N:	-1	0	0	0	1	2	3	1

N':	-1	0	0	-1	0	0	-1	1
S':	1	1	2	4	4	5	7	6
I':	0	0	0	0	0	0	0	1

经过验证 S' 确实是符合要求的;

下面写实现它的伪代码:

	1. 求出KMP 的 next[];(我们记原字符串为C-context串;模式串为P-pattern)
	2. 循环:
			查看每一个next[j] 的值, 如果为 -1 循环结束;
			c++的实现
			for(int i=0;i<len(P);i++){
				while(true){
					if(next[i]==-1){
						break;
					}else if(P[i]!=P[next[i]]){
						break;
					}else{
						next[i] = next[next[i]];
					}
				}
			}

	3. 令 i=0;j=0; 我们知道i和j的范围;
		0 <= i <= c-p+1 (c表示c串的长度,p表示p串的长度);当i取到上界时,结果是匹配失败
		0 <= j <= p (当j取到上界,结果是匹配成功);

	4. 构造循环:
		比较 C[i+j] == P[j];
		如果相等, 则j++(比较下一个字母,i不变);
		如果不等(即第j个字母不匹配,前j-1个字母匹配), 则我们去查next[j]赋值给index;然后我们计算出需要移动的步数step = j-index;
		于是  i += step; 然后比较不一定是从0开始比, 而是从 (index==-1?0:index) 开始比,于是把 值 赋值给 j;
		得到新的i和j; 进行循环条件的判断(i==c-p+1 || j==p);


    def getNext(s):
        l = len(s)
        next = [0] * (l)
        next[0] = -1

        i,j = 0, -1

        while i < l-1:
            print
            if j==-1 or s[i] == s[j]:
                i+=1
                j+=1
                next[i] = j
            else:
                j = next[j]
        return next